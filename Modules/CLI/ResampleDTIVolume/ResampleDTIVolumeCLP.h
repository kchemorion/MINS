// This file was automatically generated by:
//  /home/blvksh33p/Documents/Slicer-SuperBuild-Debug/SlicerExecutionModel-build/GenerateCLP/bin/GenerateCLP --logoFiles /home/blvksh33p/Documents/Slicer-SuperBuild-Debug/slicersources-src/Resources/NAMICLogo.h --InputXML /home/blvksh33p/Documents/Slicer-SuperBuild-Debug/slicersources-src/Modules/CLI/ResampleDTIVolume/ResampleDTIVolume.xml --OutputCxx /home/blvksh33p/Documents/Slicer-SuperBuild-Debug/Slicer-build/Modules/CLI/ResampleDTIVolume/ResampleDTIVolumeCLP.h
//
#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <string>
#include <vector>
#include <map>

#include <sstream>

#include "tclap/CmdLine.h"
#include "ModuleProcessInformation.h"

#ifdef _WIN32
#define Module_EXPORT __declspec(dllexport)
#elif defined(MODULE_HIDDEN_VISIBILITY)
#define Module_EXPORT __attribute__((visibility("default")))
#else
#define Module_EXPORT
#endif

#if defined(main) && !defined(REGISTER_TEST)
// If main defined as a preprocessor symbol, redefine it to the expected entry point.
#undef main
#define main ModuleEntryPoint

extern "C" {
  Module_EXPORT char *GetXMLModuleDescription();
  Module_EXPORT int ModuleEntryPoint(int, char*[]);
  Module_EXPORT unsigned char *GetModuleLogo(int *width, int *height, int *pixel_size, unsigned long *bufferLength);
}
#endif

extern "C" {
Module_EXPORT char XMLModuleDescription[] = 
"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"
"<executable>\n"
"  <category>Diffusion.Utilities</category>\n"
"  <title>Resample DTI Volume</title>\n"
"  <description><![CDATA[Resampling an image is a very important task in image analysis. It is especially important in the frame of image registration. This module implements DT image resampling through the use of itk Transforms. The resampling is controlled by the Output Spacing. \"Resampling\" is performed in space coordinates, not pixel/grid coordinates. It is quite important to ensure that image spacing is properly set on the images involved. The interpolator is required since the mapping from one space to the other will often require evaluation of the intensity of the image at non-grid positions.]]></description>\n"
"  <version>1.0.2</version>\n"
"  <documentation-url>https://slicer.readthedocs.io/en/latest/user_guide/modules/resampledtivolume.html</documentation-url>\n"
"  <license/>\n"
"  <contributor>Francois Budin (UNC)</contributor>\n"
"  <acknowledgements><![CDATA[This work is part of the National Alliance for Medical Image Computing (NAMIC), funded by the National Institutes of Health through the NIH Roadmap for Medical Research, Grant U54 EB005149. Information on the National Centers for Biomedical Computing can be obtained from http://nihroadmap.nih.gov/bioinformatics]]></acknowledgements>\n"
"  <parameters>\n"
"    <label>Input/Output</label>\n"
"    <description><![CDATA[Input/output parameters]]></description>\n"
"    <image type=\"tensor\">\n"
"      <name>inputVolume</name>\n"
"      <label>Input Volume</label>\n"
"      <channel>input</channel>\n"
"      <index>0</index>\n"
"      <description><![CDATA[Input volume to be resampled]]></description>\n"
"    </image>\n"
"    <image type=\"tensor\" reference=\"inputVolume\">\n"
"      <name>outputVolume</name>\n"
"      <label>Output Volume</label>\n"
"      <channel>output</channel>\n"
"      <index>1</index>\n"
"      <description><![CDATA[Resampled Volume]]></description>\n"
"    </image>\n"
"    <image type=\"any\">\n"
"      <name>referenceVolume</name>\n"
"      <label>Reference Volume (To Set Output Parameters)</label>\n"
"      <channel>input</channel>\n"
"      <flag>-R</flag>\n"
"      <longflag>--Reference</longflag>\n"
"      <description><![CDATA[Reference Volume (spacing,size,orientation,origin)]]></description>\n"
"      <default/>\n"
"    </image>\n"
"  </parameters>\n"
"  <parameters>\n"
"    <label>Transform Parameters</label>\n"
"    <description><![CDATA[Parameters used to transform the input image into the output image]]></description>\n"
"    <transform fileExtensions=\".h5\">\n"
"      <name>transformationFile</name>\n"
"      <label>Transform Node</label>\n"
"      <flag>-f</flag>\n"
"      <longflag>--transformationFile</longflag>\n"
"      <default/>\n"
"      <channel>input</channel>\n"
"    </transform>\n"
"    <image type=\"vector\">\n"
"      <name>deffield</name>\n"
"      <label>Deformation Field Volume</label>\n"
"      <channel>input</channel>\n"
"      <flag>-H</flag>\n"
"      <longflag>--defField</longflag>\n"
"      <description><![CDATA[File containing the deformation field (3D vector image containing vectors with 3 components)]]></description>\n"
"      <default/>\n"
"    </image>\n"
"    <string-enumeration>\n"
"      <name>typeOfField</name>\n"
"      <longflag>--hfieldtype</longflag>\n"
"      <description><![CDATA[Set if the deformation field is an -Field]]></description>\n"
"      <label>Displacement or h-Field</label>\n"
"      <element>displacement</element>\n"
"      <element>h-Field</element>\n"
"      <default>h-Field</default>\n"
"    </string-enumeration>\n"
"  </parameters>\n"
"  <parameters>\n"
"    <label>Processing Options</label>\n"
"    <string-enumeration>\n"
"      <name>interpolationType</name>\n"
"      <flag>-i</flag>\n"
"      <longflag>--interpolation</longflag>\n"
"      <description><![CDATA[Sampling algorithm (linear , nn (nearest neighbor), ws (WindowedSinc), bs (BSpline) )]]></description>\n"
"      <label>Interpolation</label>\n"
"      <element>linear</element>\n"
"      <element>nn</element>\n"
"      <element>ws</element>\n"
"      <element>bs</element>\n"
"      <default>linear</default>\n"
"    </string-enumeration>\n"
"    <boolean>\n"
"      <name>noMeasurementFrame</name>\n"
"      <longflag>--noMeasurementFrame</longflag>\n"
"      <description><![CDATA[Do not use the measurement frame that is in the input image to transform the tensors. Uses the image orientation instead]]></description>\n"
"      <label>No Measurement Frame</label>\n"
"      <default>false</default>\n"
"    </boolean>\n"
"    <string-enumeration>\n"
"      <name>correction</name>\n"
"      <longflag>--correction</longflag>\n"
"      <description><![CDATA[Correct the tensors if computed tensor is not semi-definite positive]]></description>\n"
"      <label>Tensors Correction</label>\n"
"      <element>zero</element>\n"
"      <element>none</element>\n"
"      <element>abs</element>\n"
"      <element>nearest</element>\n"
"      <default>zero</default>\n"
"    </string-enumeration>\n"
"  </parameters>\n"
"  <parameters advanced=\"true\">\n"
"    <label>Tensor Transform Type</label>\n"
"    <string-enumeration>\n"
"      <name>ppd</name>\n"
"      <longflag>--transform_tensor_method</longflag>\n"
"      <flag>-T</flag>\n"
"      <description><![CDATA[Chooses between 2 methods to transform the tensors: Finite Strain (FS), faster but less accurate, or Preservation of the Principal Direction (PPD)]]></description>\n"
"      <label>Finite Strain (FS) or \nPreservation of the Principal Direction (PPD)</label>\n"
"      <element>PPD</element>\n"
"      <element>FS</element>\n"
"      <default>PPD</default>\n"
"    </string-enumeration>\n"
"  </parameters>\n"
"  <parameters advanced=\"true\">\n"
"    <label>Advanced Transform Parameters</label>\n"
"    <description><![CDATA[Those parameters should normally not be modified]]></description>\n"
"    <string-enumeration>\n"
"      <name>transformsOrder</name>\n"
"      <longflag>--transform_order</longflag>\n"
"      <description><![CDATA[Select in what order the transforms are read]]></description>\n"
"      <label>Transforms Order</label>\n"
"      <element>input-to-output</element>\n"
"      <element>output-to-input</element>\n"
"      <default>output-to-input</default>\n"
"    </string-enumeration>\n"
"    <boolean>\n"
"      <name>notbulk</name>\n"
"      <longflag>--notbulk</longflag>\n"
"      <description><![CDATA[The transform following the BSpline transform is not set as a bulk transform for the BSpline transform]]></description>\n"
"      <label>Not a Bulk Transform</label>\n"
"      <default>false</default>\n"
"    </boolean>\n"
"    <boolean>\n"
"      <name>space</name>\n"
"      <longflag>--spaceChange</longflag>\n"
"      <description><![CDATA[Space Orientation between transform and image is different (RAS/LPS) (warning: if the transform is a Transform Node in Slicer3, do not select)]]></description>\n"
"      <label>Space Orientation inconsistency (between transform and image)</label>\n"
"      <default>false</default>\n"
"    </boolean>\n"
"  </parameters>\n"
"  <parameters advanced=\"true\">\n"
"    <label>Advanced Rigid/Affine Parameters</label>\n"
"    <point multiple=\"false\" coordinateSystem=\"lps\">\n"
"      <name>rotationPoint</name>\n"
"      <flag>-r</flag>\n"
"      <longflag>--rotation_point</longflag>\n"
"      <description><![CDATA[Center of rotation (only for rigid and affine transforms)]]></description>\n"
"      <label>Rotation Center</label>\n"
"      <default>0,0,0</default>\n"
"    </point>\n"
"    <boolean>\n"
"      <name>centeredTransform</name>\n"
"      <flag>-c</flag>\n"
"      <longflag>--centered_transform</longflag>\n"
"      <description><![CDATA[Set the center of the transformation to the center of the input image (only for rigid and affine transforms)]]></description>\n"
"      <label>Centered Transform</label>\n"
"      <default>false</default>\n"
"    </boolean>\n"
"    <string-enumeration>\n"
"      <name>imageCenter</name>\n"
"      <longflag>--image_center</longflag>\n"
"      <description><![CDATA[Image to use to center the transform (used only if \"Centered Transform\" is selected)]]></description>\n"
"      <label>Image Center</label>\n"
"      <element>input</element>\n"
"      <element>output</element>\n"
"      <default>input</default>\n"
"    </string-enumeration>\n"
"    <boolean>\n"
"      <name>inverseITKTransformation</name>\n"
"      <flag>-b</flag>\n"
"      <longflag>--Inverse_ITK_Transformation</longflag>\n"
"      <description><![CDATA[Inverse the transformation before applying it from output image to input image (only for rigid and affine transforms)]]></description>\n"
"      <label>Inverse Transformation</label>\n"
"      <default>false</default>\n"
"    </boolean>\n"
"  </parameters>\n"
"  <parameters advanced=\"true\">\n"
"    <label>Manual Output Parameters</label>\n"
"    <description><![CDATA[Parameters of the output image]]></description>\n"
"    <double-vector>\n"
"      <name>outputImageSpacing</name>\n"
"      <flag>-s</flag>\n"
"      <longflag>--spacing</longflag>\n"
"      <description><![CDATA[Spacing along each dimension (0 means use input spacing)]]></description>\n"
"      <label>Spacing</label>\n"
"      <default>0,0,0</default>\n"
"    </double-vector>\n"
"    <double-vector>\n"
"      <name>outputImageSize</name>\n"
"      <flag>-z</flag>\n"
"      <longflag>--size</longflag>\n"
"      <description><![CDATA[Size along each dimension (0 means use input size)]]></description>\n"
"      <label>Size</label>\n"
"      <default>0,0,0</default>\n"
"    </double-vector>\n"
"    <point multiple=\"false\" coordinateSystem=\"lps\">\n"
"      <name>outputImageOrigin</name>\n"
"      <flag>-O</flag>\n"
"      <longflag>--origin</longflag>\n"
"      <description><![CDATA[Origin of the output Image]]></description>\n"
"      <label>Origin</label>\n"
"      <default/>\n"
"    </point>\n"
"    <double-vector>\n"
"      <name>directionMatrix</name>\n"
"      <flag>-d</flag>\n"
"      <longflag>--direction_matrix</longflag>\n"
"      <description><![CDATA[9 parameters of the direction matrix by rows (ijk to LPS if LPS transform, ijk to RAS if RAS transform)]]></description>\n"
"      <label>Direction Matrix</label>\n"
"      <default>0,0,0,0,0,0,0,0,0</default>\n"
"    </double-vector>\n"
"  </parameters>\n"
"  <parameters advanced=\"true\">\n"
"    <label>Advanced Resampling Parameters</label>\n"
"    <description><![CDATA[Parameters used for resampling]]></description>\n"
"    <integer>\n"
"      <name>numberOfThread</name>\n"
"      <flag>-n</flag>\n"
"      <longflag>--number_of_thread</longflag>\n"
"      <description><![CDATA[Number of thread used to compute the output image]]></description>\n"
"      <label>Number Of Threads</label>\n"
"      <default>0</default>\n"
"    </integer>\n"
"    <double>\n"
"      <name>defaultPixelValue</name>\n"
"      <flag>-p</flag>\n"
"      <longflag>--default_pixel_value</longflag>\n"
"      <description><![CDATA[Default pixel value for samples falling outside of the input region]]></description>\n"
"      <label>Default Pixel Value</label>\n"
"      <default>1e-10</default>\n"
"    </double>\n"
"  </parameters>\n"
"  <parameters advanced=\"true\">\n"
"    <label>Windowed Sinc Interpolate Function Parameters</label>\n"
"    <description><![CDATA[Parameters used for the Windowed Sinc interpolation]]></description>\n"
"    <string-enumeration>\n"
"      <name>windowFunction</name>\n"
"      <flag>-W</flag>\n"
"      <longflag>--window_function</longflag>\n"
"      <description><![CDATA[Window Function \nh = Hamming \nc = Cosine \nw = Welch \nl = Lanczos \nb = Blackman]]></description>\n"
"      <label>Window Function</label>\n"
"      <element>h</element>\n"
"      <element>c</element>\n"
"      <element>w</element>\n"
"      <element>l</element>\n"
"      <element>b</element>\n"
"      <default>c</default>\n"
"    </string-enumeration>\n"
"  </parameters>\n"
"  <parameters advanced=\"true\">\n"
"    <label>BSpline Interpolate Function Parameters</label>\n"
"    <description><![CDATA[Parameters used for the BSpline interpolation]]></description>\n"
"    <integer>\n"
"      <name>splineOrder</name>\n"
"      <flag>-o</flag>\n"
"      <longflag>--spline_order</longflag>\n"
"      <description><![CDATA[Spline Order (Spline order may be from 0 to 5)]]></description>\n"
"      <label>Spline Order</label>\n"
"      <default>3</default>\n"
"    </integer>\n"
"  </parameters>\n"
"  <parameters advanced=\"true\">\n"
"    <label>Manual Transform (Used only if no transform node set)</label>\n"
"    <double-vector>\n"
"      <name>transformMatrix</name>\n"
"      <flag>-m</flag>\n"
"      <longflag>--transform_matrix</longflag>\n"
"      <description><![CDATA[12 parameters of the transform matrix by rows ( --last 3 being translation-- )]]></description>\n"
"      <label>Transform Matrix</label>\n"
"      <default>1,0,0,0,1,0,0,0,1,0,0,0</default>\n"
"    </double-vector>\n"
"    <string-enumeration>\n"
"      <name>transformType</name>\n"
"      <flag>-t</flag>\n"
"      <longflag>--transform</longflag>\n"
"      <description><![CDATA[Transform algorithm\nrt = Rigid Transform\na = Affine Transform]]></description>\n"
"      <label>Transform Type</label>\n"
"      <element>rt</element>\n"
"      <element>a</element>\n"
"      <default>a</default>\n"
"    </string-enumeration>\n"
"  </parameters>\n"
"</executable>\n"
"\n"
;

#define static Module_EXPORT
#define const
#define image_NAMICLogo_width ModuleLogoWidth
#define image_NAMICLogo_height ModuleLogoHeight
#define image_NAMICLogo_pixel_size ModuleLogoPixelSize
#define image_NAMICLogo_length ModuleLogoLength
#define image_NAMICLogo ModuleLogoImage
#include "/home/blvksh33p/Documents/Slicer-SuperBuild-Debug/slicersources-src/Resources/NAMICLogo.h"
#undef static
#undef const
#undef image_NAMICLogo_width
#undef image_NAMICLogo_height
#undef image_NAMICLogo_pixel_size
#undef image_NAMICLogo_length
#undef image_NAMICLogo
}

void
splitString (const std::string &text,
             const std::string &separators,
             std::vector<std::string> &words)
{
  const std::string::size_type n = text.length();
  std::string::size_type start = text.find_first_not_of(separators);
  while (start < n)
    {
    std::string::size_type stop = text.find_first_of(separators, start);
    if (stop > n) stop = n;
    words.push_back(text.substr(start, stop - start));
    start = text.find_first_not_of(separators, stop+1);
    }
}

void
splitFilenames (const std::string &text,
                std::vector<std::string> &words)
{
  const std::string::size_type n = text.length();
  bool quoted;
  std::string comma(",");
  std::string quote("\"");
  std::string::size_type start = text.find_first_not_of(comma);
  while (start < n)
    {
    quoted = false;
    std::string::size_type startq = text.find_first_of(quote, start);
    std::string::size_type stopq = text.find_first_of(quote, startq+1);
    std::string::size_type stop = text.find_first_of(comma, start);
    if (stop > n) stop = n;
    if (startq != std::string::npos && stopq != std::string::npos)
      {
      while (startq < stop && stop < stopq && stop != n)
         {
         quoted = true;
         stop = text.find_first_of(comma, stop+1);
         if (stop > n) stop = n;
         }
      }
    if (!quoted)
      {
      words.push_back(text.substr(start, stop - start));
      }
    else
      {
      words.push_back(text.substr(start+1, stop - start-2));
      }
    start = text.find_first_not_of(comma, stop+1);
    }
}

unsigned char *GetModuleLogo(int *width,
                             int *height,
                             int *pixel_size,
                             unsigned long *length)
{
  *width = ModuleLogoWidth;
  *height = ModuleLogoHeight;
  *pixel_size = ModuleLogoPixelSize;
  *length = ModuleLogoLength;
  return const_cast<unsigned char *>(ModuleLogoImage);
}

char *GetXMLModuleDescription()
{
   return XMLModuleDescription;
}

#define GENERATE_LOGO \
  if (argc >= 2 && (strcmp(argv[1],"--logo") == 0)) \
    { \
    int width, height, pixel_size;     \
    unsigned long length;  \
    unsigned char *logo = GetModuleLogo(&width, &height, &pixel_size, &length);  \
    std::cout << "LOGO" << std::endl;  \
    std::cout << width << std::endl;  \
    std::cout << height << std::endl;  \
    std::cout << pixel_size << std::endl;  \
    std::cout << length << std::endl;  \
    std::cout << logo << std::endl;  \
    return EXIT_SUCCESS;  \
    }
#define GENERATE_XML \
  if (argc >= 2 && (strcmp(argv[1],"--xml") == 0)) \
    { \
    std::cout << GetXMLModuleDescription(); \
    return EXIT_SUCCESS; \
    }
#define GENERATE_DECLARE \
    /* These two vectors are used to store the JSON deserialized value */ \
    /* that are then compiled with the command line. */ \
    std::vector< std::string > deserializedVectorFlaggedArgs; \
    std::vector< std::string > deserializedVectorPositionalArgs; \
    /* This map is used to store the JSON deserialized value of multiple args*/ \
    /* where the key is the argument flag and the value the values of each arg. */ \
    std::map< std::string, std::vector<std::string> > deserializedMultipleArgsMap; \
 \
    /* This vector is used to look up if a flag requires an argument after it. */ \
    /* This is used to differentiate between: */ \
    /* ./myExec --boolFlag /my/first/arg */ \
    /* ./myExec --flag flagArg */ \
    std::vector< std::string > nonbooleanFlags; \
    nonbooleanFlags.push_back("-R"); \
    nonbooleanFlags.push_back("--Reference"); \
    nonbooleanFlags.push_back("-f"); \
    nonbooleanFlags.push_back("--transformationFile"); \
    nonbooleanFlags.push_back("-H"); \
    nonbooleanFlags.push_back("--defField"); \
    nonbooleanFlags.push_back("--hfieldtype"); \
    nonbooleanFlags.push_back("-i"); \
    nonbooleanFlags.push_back("--interpolation"); \
    nonbooleanFlags.push_back("--correction"); \
    nonbooleanFlags.push_back("-T"); \
    nonbooleanFlags.push_back("--transform_tensor_method"); \
    nonbooleanFlags.push_back("--transform_order"); \
    nonbooleanFlags.push_back("-r"); \
    nonbooleanFlags.push_back("--rotation_point"); \
    nonbooleanFlags.push_back("--image_center"); \
    nonbooleanFlags.push_back("-s"); \
    nonbooleanFlags.push_back("--spacing"); \
    nonbooleanFlags.push_back("-z"); \
    nonbooleanFlags.push_back("--size"); \
    nonbooleanFlags.push_back("-O"); \
    nonbooleanFlags.push_back("--origin"); \
    nonbooleanFlags.push_back("-d"); \
    nonbooleanFlags.push_back("--direction_matrix"); \
    nonbooleanFlags.push_back("-n"); \
    nonbooleanFlags.push_back("--number_of_thread"); \
    nonbooleanFlags.push_back("-p"); \
    nonbooleanFlags.push_back("--default_pixel_value"); \
    nonbooleanFlags.push_back("-W"); \
    nonbooleanFlags.push_back("--window_function"); \
    nonbooleanFlags.push_back("-o"); \
    nonbooleanFlags.push_back("--spline_order"); \
    nonbooleanFlags.push_back("-m"); \
    nonbooleanFlags.push_back("--transform_matrix"); \
    nonbooleanFlags.push_back("-t"); \
    nonbooleanFlags.push_back("--transform"); \
    nonbooleanFlags.push_back("--processinformationaddress"); \
    nonbooleanFlags.push_back("--returnparameterfile"); \
    /* This map use is twofold: */ \
    /*  - to find whether a flag is multiple */ \
    /*  - to know if we need to reset the multiple arg value because it was */ \
    /*    in the JSON and it's also in the command line. */ \
    std::map<std::string, bool> multipleFlags; \
    std::string inputVolume; \
    std::string outputVolume; \
    std::string referenceVolume; \
    std::string transformationFile; \
    std::string deffield; \
    std::string typeOfField = "h-Field"; \
    std::vector<std::string> typeOfFieldAllowed; \
    typeOfFieldAllowed.push_back("displacement");  \
    typeOfFieldAllowed.push_back("h-Field");  \
    TCLAP::ValuesConstraint<std::string> typeOfFieldAllowedVals (typeOfFieldAllowed);  \
    std::string interpolationType = "linear"; \
    std::vector<std::string> interpolationTypeAllowed; \
    interpolationTypeAllowed.push_back("linear");  \
    interpolationTypeAllowed.push_back("nn");  \
    interpolationTypeAllowed.push_back("ws");  \
    interpolationTypeAllowed.push_back("bs");  \
    TCLAP::ValuesConstraint<std::string> interpolationTypeAllowedVals (interpolationTypeAllowed);  \
    bool noMeasurementFrame = false; \
    std::string correction = "zero"; \
    std::vector<std::string> correctionAllowed; \
    correctionAllowed.push_back("zero");  \
    correctionAllowed.push_back("none");  \
    correctionAllowed.push_back("abs");  \
    correctionAllowed.push_back("nearest");  \
    TCLAP::ValuesConstraint<std::string> correctionAllowedVals (correctionAllowed);  \
    std::string ppd = "PPD"; \
    std::vector<std::string> ppdAllowed; \
    ppdAllowed.push_back("PPD");  \
    ppdAllowed.push_back("FS");  \
    TCLAP::ValuesConstraint<std::string> ppdAllowedVals (ppdAllowed);  \
    std::string transformsOrder = "output-to-input"; \
    std::vector<std::string> transformsOrderAllowed; \
    transformsOrderAllowed.push_back("input-to-output");  \
    transformsOrderAllowed.push_back("output-to-input");  \
    TCLAP::ValuesConstraint<std::string> transformsOrderAllowedVals (transformsOrderAllowed);  \
    bool notbulk = false; \
    bool space = false; \
    std::string rotationPointTemp = "0,0,0"; \
    std::vector<float> rotationPoint; \
    bool centeredTransform = false; \
    std::string imageCenter = "input"; \
    std::vector<std::string> imageCenterAllowed; \
    imageCenterAllowed.push_back("input");  \
    imageCenterAllowed.push_back("output");  \
    TCLAP::ValuesConstraint<std::string> imageCenterAllowedVals (imageCenterAllowed);  \
    bool inverseITKTransformation = false; \
    std::string outputImageSpacingTemp = "0,0,0"; \
    std::vector<double> outputImageSpacing; \
    std::string outputImageSizeTemp = "0,0,0"; \
    std::vector<double> outputImageSize; \
    std::string outputImageOriginTemp; \
    std::vector<float> outputImageOrigin; \
    std::string directionMatrixTemp = "0,0,0,0,0,0,0,0,0"; \
    std::vector<double> directionMatrix; \
    int numberOfThread = 0; \
    double defaultPixelValue = 1e-10; \
    std::string windowFunction = "c"; \
    std::vector<std::string> windowFunctionAllowed; \
    windowFunctionAllowed.push_back("h");  \
    windowFunctionAllowed.push_back("c");  \
    windowFunctionAllowed.push_back("w");  \
    windowFunctionAllowed.push_back("l");  \
    windowFunctionAllowed.push_back("b");  \
    TCLAP::ValuesConstraint<std::string> windowFunctionAllowedVals (windowFunctionAllowed);  \
    int splineOrder = 3; \
    std::string transformMatrixTemp = "1,0,0,0,1,0,0,0,1,0,0,0"; \
    std::vector<double> transformMatrix; \
    std::string transformType = "a"; \
    std::vector<std::string> transformTypeAllowed; \
    transformTypeAllowed.push_back("rt");  \
    transformTypeAllowed.push_back("a");  \
    TCLAP::ValuesConstraint<std::string> transformTypeAllowedVals (transformTypeAllowed);  \
    bool echoSwitch = false; \
    bool xmlSwitch = false; \
    std::string processInformationAddressString = "0"; \
    std::string returnParameterFile; \

#define GENERATE_TCLAP_PARSE \
    std::string fullDescription("Description: "); \
    fullDescription += "Resampling an image is a very important task in image analysis. It is especially important in the frame of image registration. This module implements DT image resampling through the use of itk Transforms. The resampling is controlled by the Output Spacing. 'Resampling' is performed in space coordinates, not pixel/grid coordinates. It is quite important to ensure that image spacing is properly set on the images involved. The interpolator is required since the mapping from one space to the other will often require evaluation of the intensity of the image at non-grid positions."; \
    if (!std::string("Francois Budin (UNC)").empty()) \
      { \
      fullDescription += "\nAuthor(s): Francois Budin (UNC)"; \
      } \
    if (!std::string("This work is part of the National Alliance for Medical Image Computing (NAMIC), funded by the National Institutes of Health through the NIH Roadmap for Medical Research, Grant U54 EB005149. Information on the National Centers for Biomedical Computing can be obtained from http://nihroadmap.nih.gov/bioinformatics").empty()) \
      { \
      fullDescription += "\nAcknowledgements: This work is part of the National Alliance for Medical Image Computing (NAMIC), funded by the National Institutes of Health through the NIH Roadmap for Medical Research, Grant U54 EB005149. Information on the National Centers for Biomedical Computing can be obtained from http://nihroadmap.nih.gov/bioinformatics"; \
      } \
    TCLAP::CmdLine commandLine (fullDescription, \
       ' ', \
      "1.0.2" ); \
 \
      std::ostringstream msg; \
    msg.str("");msg << "Input volume to be resampled";    TCLAP::UnlabeledValueArg<std::string> inputVolumeArg("inputVolume", msg.str(), 1, inputVolume, "std::string", commandLine); \
 \
    msg.str("");msg << "Resampled Volume";    TCLAP::UnlabeledValueArg<std::string> outputVolumeArg("outputVolume", msg.str(), 1, outputVolume, "std::string", commandLine); \
 \
    msg.str("");msg << "Reference Volume (spacing,size,orientation,origin)";    TCLAP::ValueArg<std::string > referenceVolumeArg("R", "Reference", msg.str(), 0, referenceVolume, "std::string", commandLine); \
 \
    msg.str("");msg << "";    TCLAP::ValueArg<std::string > transformationFileArg("f", "transformationFile", msg.str(), 0, transformationFile, "std::string", commandLine); \
 \
    msg.str("");msg << "File containing the deformation field (3D vector image containing vectors with 3 components)";    TCLAP::ValueArg<std::string > deffieldArg("H", "defField", msg.str(), 0, deffield, "std::string", commandLine); \
 \
    msg.str("");msg << "Set if the deformation field is an -Field (value: " << typeOfField << ")"; \
    TCLAP::ValueArg<std::string> typeOfFieldArg("", "hfieldtype", msg.str(), 0, typeOfField, &typeOfFieldAllowedVals, commandLine); \
 \
    msg.str("");msg << "Sampling algorithm (linear , nn (nearest neighbor), ws (WindowedSinc), bs (BSpline) ) (value: " << interpolationType << ")"; \
    TCLAP::ValueArg<std::string> interpolationTypeArg("i", "interpolation", msg.str(), 0, interpolationType, &interpolationTypeAllowedVals, commandLine); \
 \
    msg.str("");msg << "Do not use the measurement frame that is in the input image to transform the tensors. Uses the image orientation instead (value: " << noMeasurementFrame << ")"; \
    TCLAP::SwitchArg noMeasurementFrameArg("", "noMeasurementFrame", msg.str(), commandLine, noMeasurementFrame); \
 \
    msg.str("");msg << "Correct the tensors if computed tensor is not semi-definite positive (value: " << correction << ")"; \
    TCLAP::ValueArg<std::string> correctionArg("", "correction", msg.str(), 0, correction, &correctionAllowedVals, commandLine); \
 \
    msg.str("");msg << "Chooses between 2 methods to transform the tensors: Finite Strain (FS), faster but less accurate, or Preservation of the Principal Direction (PPD) (value: " << ppd << ")"; \
    TCLAP::ValueArg<std::string> ppdArg("T", "transform_tensor_method", msg.str(), 0, ppd, &ppdAllowedVals, commandLine); \
 \
    msg.str("");msg << "Select in what order the transforms are read (value: " << transformsOrder << ")"; \
    TCLAP::ValueArg<std::string> transformsOrderArg("", "transform_order", msg.str(), 0, transformsOrder, &transformsOrderAllowedVals, commandLine); \
 \
    msg.str("");msg << "The transform following the BSpline transform is not set as a bulk transform for the BSpline transform (value: " << notbulk << ")"; \
    TCLAP::SwitchArg notbulkArg("", "notbulk", msg.str(), commandLine, notbulk); \
 \
    msg.str("");msg << "Space Orientation between transform and image is different (RAS/LPS) (warning: if the transform is a Transform Node in Slicer3, do not select) (value: " << space << ")"; \
    TCLAP::SwitchArg spaceArg("", "spaceChange", msg.str(), commandLine, space); \
 \
    msg.str("");msg << "Center of rotation (only for rigid and affine transforms) (value: " << rotationPointTemp << ")"; \
    TCLAP::ValueArg<std::string > rotationPointArg("r", "rotation_point", msg.str(), 0, rotationPointTemp, "std::vector<float>", commandLine); \
 \
    msg.str("");msg << "Set the center of the transformation to the center of the input image (only for rigid and affine transforms) (value: " << centeredTransform << ")"; \
    TCLAP::SwitchArg centeredTransformArg("c", "centered_transform", msg.str(), commandLine, centeredTransform); \
 \
    msg.str("");msg << "Image to use to center the transform (used only if 'Centered Transform' is selected) (value: " << imageCenter << ")"; \
    TCLAP::ValueArg<std::string> imageCenterArg("", "image_center", msg.str(), 0, imageCenter, &imageCenterAllowedVals, commandLine); \
 \
    msg.str("");msg << "Inverse the transformation before applying it from output image to input image (only for rigid and affine transforms) (value: " << inverseITKTransformation << ")"; \
    TCLAP::SwitchArg inverseITKTransformationArg("b", "Inverse_ITK_Transformation", msg.str(), commandLine, inverseITKTransformation); \
 \
    msg.str("");msg << "Spacing along each dimension (0 means use input spacing) (value: " << outputImageSpacingTemp << ")"; \
    TCLAP::ValueArg<std::string > outputImageSpacingArg("s", "spacing", msg.str(), 0, outputImageSpacingTemp, "std::vector<double>", commandLine); \
 \
    msg.str("");msg << "Size along each dimension (0 means use input size) (value: " << outputImageSizeTemp << ")"; \
    TCLAP::ValueArg<std::string > outputImageSizeArg("z", "size", msg.str(), 0, outputImageSizeTemp, "std::vector<double>", commandLine); \
 \
    msg.str("");msg << "Origin of the output Image";    TCLAP::ValueArg<std::string > outputImageOriginArg("O", "origin", msg.str(), 0, outputImageOriginTemp, "std::vector<float>", commandLine); \
 \
    msg.str("");msg << "9 parameters of the direction matrix by rows (ijk to LPS if LPS transform, ijk to RAS if RAS transform) (value: " << directionMatrixTemp << ")"; \
    TCLAP::ValueArg<std::string > directionMatrixArg("d", "direction_matrix", msg.str(), 0, directionMatrixTemp, "std::vector<double>", commandLine); \
 \
    msg.str("");msg << "Number of thread used to compute the output image (value: " << numberOfThread << ")"; \
    TCLAP::ValueArg<int > numberOfThreadArg("n", "number_of_thread", msg.str(), 0, numberOfThread, "int", commandLine); \
 \
    msg.str("");msg << "Default pixel value for samples falling outside of the input region (value: " << defaultPixelValue << ")"; \
    TCLAP::ValueArg<double > defaultPixelValueArg("p", "default_pixel_value", msg.str(), 0, defaultPixelValue, "double", commandLine); \
 \
    msg.str("");msg << "Window Function \nh = Hamming \nc = Cosine \nw = Welch \nl = Lanczos \nb = Blackman (value: " << windowFunction << ")"; \
    TCLAP::ValueArg<std::string> windowFunctionArg("W", "window_function", msg.str(), 0, windowFunction, &windowFunctionAllowedVals, commandLine); \
 \
    msg.str("");msg << "Spline Order (Spline order may be from 0 to 5) (value: " << splineOrder << ")"; \
    TCLAP::ValueArg<int > splineOrderArg("o", "spline_order", msg.str(), 0, splineOrder, "int", commandLine); \
 \
    msg.str("");msg << "12 parameters of the transform matrix by rows ( --last 3 being translation-- ) (value: " << transformMatrixTemp << ")"; \
    TCLAP::ValueArg<std::string > transformMatrixArg("m", "transform_matrix", msg.str(), 0, transformMatrixTemp, "std::vector<double>", commandLine); \
 \
    msg.str("");msg << "Transform algorithm\nrt = Rigid Transform\na = Affine Transform (value: " << transformType << ")"; \
    TCLAP::ValueArg<std::string> transformTypeArg("t", "transform", msg.str(), 0, transformType, &transformTypeAllowedVals, commandLine); \
 \
    msg.str("");msg << "Echo the command line arguments (value: " << echoSwitch << ")"; \
    TCLAP::SwitchArg echoSwitchArg("", "echo", msg.str(), commandLine, echoSwitch); \
 \
    msg.str("");msg << "Produce xml description of command line arguments (value: " << xmlSwitch << ")"; \
    TCLAP::SwitchArg xmlSwitchArg("", "xml", msg.str(), commandLine, xmlSwitch); \
 \
    msg.str("");msg << "Address of a structure to store process information (progress, abort, etc.). (value: " << processInformationAddressString << ")"; \
    TCLAP::ValueArg<std::string > processInformationAddressStringArg("", "processinformationaddress", msg.str(), 0, processInformationAddressString, "std::string", commandLine); \
 \
    msg.str("");msg << "Filename in which to write simple return parameters (int, float, int-vector, etc.) as opposed to bulk return parameters (image, geometry, transform, measurement, table).";    TCLAP::ValueArg<std::string > returnParameterFileArg("", "returnparameterfile", msg.str(), 0, returnParameterFile, "std::string", commandLine); \
 \
try \
  { \
    /* Build a map of flag aliases to the true flag */ \
    std::map<std::string,std::string> flagAliasMap; \
    std::map<std::string,std::string> deprecatedFlagAliasMap; \
    std::map<std::string,std::string> longFlagAliasMap; \
    std::map<std::string,std::string> deprecatedLongFlagAliasMap; \
 \
    /* Go through argc and consolidate the JSON with the parameters from the command line */ \
    /* In case of conflict, take the command line. */ \
    std::map<std::string,std::string>::iterator ait; \
    std::map<std::string,std::string>::iterator dait; \
    std::vector<std::string>::iterator dvOptionnalArgsIt = deserializedVectorFlaggedArgs.begin(); \
    std::map<std::string, std::vector<std::string> >::iterator dvMultipleArgsIt; \
    size_t noFlagCounter = 0; \
    size_t ac = 1; \
 \
    while (ac < static_cast<size_t>(argc)) \
      { \
      /* short flag case && long flag case */ \
       if ((strlen(argv[ac]) == 2 && argv[ac][0]=='-') \
           || (strlen(argv[ac]) > 2 && argv[ac][0]=='-' && argv[ac][1]=='-')) \
         { \
         std::string flag = argv[ac]; \
         /* Remap the flag if necessary */ \
         if (strlen(argv[ac]) == 2) \
           { \
           /* Short flag remapping */ \
           ait = flagAliasMap.find(flag); \
           dait = deprecatedFlagAliasMap.find(flag); \
           if (ait != flagAliasMap.end()) \
             { \
             /* remap the flag */ \
             flag = (*ait).second; \
             } \
           else if (dait != deprecatedFlagAliasMap.end()) \
             { \
             std::cout << "Flag \"" << flag << "\" is deprecated. Please use flag \"" << (*dait).second << "\" instead. " << std::endl; \
             /* remap the flag */ \
             flag = (*dait).second; \
             } \
           } \
         else \
           { \
           /* Long flag remapping */ \
           ait = longFlagAliasMap.find(flag); \
           dait = deprecatedLongFlagAliasMap.find(flag); \
           if (ait != longFlagAliasMap.end()) \
             { \
             /* remap the flag */ \
             flag = (*ait).second; \
             } \
           else if (dait != deprecatedLongFlagAliasMap.end()) \
             { \
             std::cout << "Long flag \"" << flag << "\" is deprecated. Please use long flag \"" << (*dait).second << "\" instead. " << std::endl; \
             /* remap the flag */ \
             flag = (*dait).second; \
             } \
           } \
         bool isMultiple = multipleFlags.find(flag) != multipleFlags.end(); \
         bool isBoolean = std::find(nonbooleanFlags.begin(), nonbooleanFlags.end(), flag) == nonbooleanFlags.end(); \
         dvOptionnalArgsIt = std::find(deserializedVectorFlaggedArgs.begin(), deserializedVectorFlaggedArgs.end(), flag); \
         bool isPresentVFA = dvOptionnalArgsIt != deserializedVectorFlaggedArgs.end(); \
         if (isBoolean) \
           { \
           /*Ignore if boolean and already present*/ \
           /*Otherwise add it*/ \
           if (!isPresentVFA) \
             { \
             deserializedVectorFlaggedArgs.push_back(flag); \
             } \
           ++ac; \
           } \
         else if (isMultiple) \
           { \
           dvMultipleArgsIt = deserializedMultipleArgsMap.find(flag); \
           bool isPresentMA = dvMultipleArgsIt != deserializedMultipleArgsMap.end(); \
           /*Ignore if boolean and already present*/ \
           /*Reset/Add the value if first deserialize or not present*/ \
           if (!isPresentMA || !multipleFlags[flag]) \
             { \
             deserializedMultipleArgsMap[flag] = std::vector<std::string>(); \
             multipleFlags[flag] = true; \
             } \
           ++ac; \
           std::string value = ""; \
           if (ac < static_cast<size_t>(argc)) \
             { \
             value = argv[ac]; \
             ++ac; \
             } \
           deserializedMultipleArgsMap[flag].push_back(value); \
           } \
         else \
           { \
           /*Add the flag and if needed*/ \
           if (!isPresentVFA) \
             { \
             deserializedVectorFlaggedArgs.push_back(flag); \
             } \
           ++ac; \
           std::string value = ""; \
           if (ac < static_cast<size_t>(argc)) \
             { \
             value = argv[ac]; \
             ++ac; \
             } \
           if (!isPresentVFA) \
             { \
             deserializedVectorFlaggedArgs.push_back(value);  \
             } \
           else \
             { \
             *(++dvOptionnalArgsIt) = value; \
             } \
           } \
         } \
       /* short flag case where multiple flags are given at once */ \
       else if (strlen(argv[ac]) > 2 && argv[ac][0]=='-' && argv[ac][1]!='-') \
         { \
         std::string rflag(argv[ac], 1, std::string::npos); \
         for (std::string::size_type fi=0; fi < rflag.size(); ++fi) \
           { \
           std::string tf(rflag, fi, 1); \
           std::string newFlag ="-"; \
           newFlag += tf; \
           ait = flagAliasMap.find(newFlag); \
           dait = deprecatedFlagAliasMap.find(newFlag); \
           if (ait != flagAliasMap.end()) \
             { \
             /* remap the flag */ \
             newFlag = (*ait).second; \
             } \
           else if (dait != deprecatedFlagAliasMap.end()) \
             { \
             std::cout << "Flag \"" << newFlag << "\" is deprecated. Please use flag \"" << (*dait).second << "\" instead. " << std::endl; \
             /* remap the flag */ \
             newFlag = (*dait).second; \
             } \
           dvOptionnalArgsIt = std::find(deserializedVectorFlaggedArgs.begin(), deserializedVectorFlaggedArgs.end(), newFlag); \
           /*These flags are always boolean, just add it if it's not there already */ \
           if (dvOptionnalArgsIt == deserializedVectorFlaggedArgs.end()) \
             { \
             deserializedVectorFlaggedArgs.push_back(newFlag); \
             } \
           } \
         ++ac; \
         } \
       else \
         { \
         /* Replace if needed, otherwise append.*/ \
         if (noFlagCounter < deserializedVectorPositionalArgs.size()) \
           { \
           deserializedVectorPositionalArgs[noFlagCounter] = argv[ac]; \
           } \
         else \
           { \
           deserializedVectorPositionalArgs.push_back(argv[ac]); \
           } \
         ++ac; \
         ++noFlagCounter; \
         } \
       } \
 \
    /* Put the now compiled arguments in the argvVector */ \
    std::vector<std::string> argvVector; \
    argvVector.push_back(argv[0]); \
    argvVector.insert(argvVector.end(), deserializedVectorFlaggedArgs.begin(), deserializedVectorFlaggedArgs.end()); \
    std::map<std::string, std::vector<std::string> >::iterator mavit; \
    for (mavit = deserializedMultipleArgsMap.begin(); mavit != deserializedMultipleArgsMap.end(); ++mavit) \
      { \
      for (size_t i = 0; i < mavit->second.size(); ++i) \
        { \
        argvVector.push_back(mavit->first); \
        argvVector.push_back(mavit->second.at(i)); \
        } \
      } \
    argvVector.insert(argvVector.end(), deserializedVectorPositionalArgs.begin(), deserializedVectorPositionalArgs.end()); \
 \
   /* Remap args to a structure that CmdLine::parse() can understand*/ \
   std::vector<char*> vargs; \
   for (ac = 0; ac < argvVector.size(); ++ac) \
     {  \
     vargs.push_back(const_cast<char *>(argvVector[ac].c_str())); \
     } \
    commandLine.parse ( static_cast<int>(vargs.size()), (char**) &(vargs[0]) ); \
  } \
catch ( TCLAP::ArgException & e ) \
  { \
  std::cerr << "error: " << e.error() << " for arg " << e.argId() << std::endl; \
  return ( EXIT_FAILURE ); \
  }
#define GENERATE_TCLAP_ASSIGNMENT \
      inputVolume = inputVolumeArg.getValue(); \
      outputVolume = outputVolumeArg.getValue(); \
      referenceVolume = referenceVolumeArg.getValue(); \
      transformationFile = transformationFileArg.getValue(); \
      deffield = deffieldArg.getValue(); \
      typeOfField = typeOfFieldArg.getValue(); \
      interpolationType = interpolationTypeArg.getValue(); \
      noMeasurementFrame = noMeasurementFrameArg.getValue(); \
      correction = correctionArg.getValue(); \
      ppd = ppdArg.getValue(); \
      transformsOrder = transformsOrderArg.getValue(); \
      notbulk = notbulkArg.getValue(); \
      space = spaceArg.getValue(); \
      rotationPointTemp = rotationPointArg.getValue(); \
      centeredTransform = centeredTransformArg.getValue(); \
      imageCenter = imageCenterArg.getValue(); \
      inverseITKTransformation = inverseITKTransformationArg.getValue(); \
      outputImageSpacingTemp = outputImageSpacingArg.getValue(); \
      outputImageSizeTemp = outputImageSizeArg.getValue(); \
      outputImageOriginTemp = outputImageOriginArg.getValue(); \
      directionMatrixTemp = directionMatrixArg.getValue(); \
      numberOfThread = numberOfThreadArg.getValue(); \
      defaultPixelValue = defaultPixelValueArg.getValue(); \
      windowFunction = windowFunctionArg.getValue(); \
      splineOrder = splineOrderArg.getValue(); \
      transformMatrixTemp = transformMatrixArg.getValue(); \
      transformType = transformTypeArg.getValue(); \
      echoSwitch = echoSwitchArg.getValue(); \
      xmlSwitch = xmlSwitchArg.getValue(); \
      processInformationAddressString = processInformationAddressStringArg.getValue(); \
      returnParameterFile = returnParameterFileArg.getValue(); \
      { /* Assignment for rotationPoint */ \
      rotationPoint.clear(); \
      std::vector<std::string> words; \
      std::string sep(","); \
      splitString(rotationPointTemp, sep, words); \
      for (unsigned int _j = 0; _j < words.size(); _j++) \
        { \
        rotationPoint.push_back(atof(words[_j].c_str())); \
        } \
      } \
      { /* Assignment for outputImageSpacing */ \
      outputImageSpacing.clear(); \
      std::vector<std::string> words; \
      std::string sep(","); \
      splitString(outputImageSpacingTemp, sep, words); \
      for (unsigned int _j = 0; _j < words.size(); _j++) \
        { \
        outputImageSpacing.push_back(atof(words[_j].c_str())); \
        } \
      } \
      { /* Assignment for outputImageSize */ \
      outputImageSize.clear(); \
      std::vector<std::string> words; \
      std::string sep(","); \
      splitString(outputImageSizeTemp, sep, words); \
      for (unsigned int _j = 0; _j < words.size(); _j++) \
        { \
        outputImageSize.push_back(atof(words[_j].c_str())); \
        } \
      } \
      { /* Assignment for outputImageOrigin */ \
      outputImageOrigin.clear(); \
      std::vector<std::string> words; \
      std::string sep(","); \
      splitString(outputImageOriginTemp, sep, words); \
      for (unsigned int _j = 0; _j < words.size(); _j++) \
        { \
        outputImageOrigin.push_back(atof(words[_j].c_str())); \
        } \
      } \
      { /* Assignment for directionMatrix */ \
      directionMatrix.clear(); \
      std::vector<std::string> words; \
      std::string sep(","); \
      splitString(directionMatrixTemp, sep, words); \
      for (unsigned int _j = 0; _j < words.size(); _j++) \
        { \
        directionMatrix.push_back(atof(words[_j].c_str())); \
        } \
      } \
      { /* Assignment for transformMatrix */ \
      transformMatrix.clear(); \
      std::vector<std::string> words; \
      std::string sep(","); \
      splitString(transformMatrixTemp, sep, words); \
      for (unsigned int _j = 0; _j < words.size(); _j++) \
        { \
        transformMatrix.push_back(atof(words[_j].c_str())); \
        } \
      } \

#define GENERATE_TCLAP GENERATE_TCLAP_PARSE;GENERATE_TCLAP_ASSIGNMENT
#define GENERATE_TCLAP_ASSIGNMENT_IFSET \
    if( inputVolumeArg.isSet() ) \
      { \
      inputVolume = inputVolumeArg.getValue(); \
      } \
    if( outputVolumeArg.isSet() ) \
      { \
      outputVolume = outputVolumeArg.getValue(); \
      } \
    if( referenceVolumeArg.isSet() ) \
      { \
      referenceVolume = referenceVolumeArg.getValue(); \
      } \
    if( transformationFileArg.isSet() ) \
      { \
      transformationFile = transformationFileArg.getValue(); \
      } \
    if( deffieldArg.isSet() ) \
      { \
      deffield = deffieldArg.getValue(); \
      } \
    if( typeOfFieldArg.isSet() ) \
      { \
      typeOfField = typeOfFieldArg.getValue(); \
      } \
    if( interpolationTypeArg.isSet() ) \
      { \
      interpolationType = interpolationTypeArg.getValue(); \
      } \
    if( noMeasurementFrameArg.isSet() ) \
      { \
      noMeasurementFrame = noMeasurementFrameArg.getValue(); \
      } \
    if( correctionArg.isSet() ) \
      { \
      correction = correctionArg.getValue(); \
      } \
    if( ppdArg.isSet() ) \
      { \
      ppd = ppdArg.getValue(); \
      } \
    if( transformsOrderArg.isSet() ) \
      { \
      transformsOrder = transformsOrderArg.getValue(); \
      } \
    if( notbulkArg.isSet() ) \
      { \
      notbulk = notbulkArg.getValue(); \
      } \
    if( spaceArg.isSet() ) \
      { \
      space = spaceArg.getValue(); \
      } \
    if( rotationPointArg.isSet() ) \
      { \
      rotationPointTemp = rotationPointArg.getValue(); \
      } \
    if( centeredTransformArg.isSet() ) \
      { \
      centeredTransform = centeredTransformArg.getValue(); \
      } \
    if( imageCenterArg.isSet() ) \
      { \
      imageCenter = imageCenterArg.getValue(); \
      } \
    if( inverseITKTransformationArg.isSet() ) \
      { \
      inverseITKTransformation = inverseITKTransformationArg.getValue(); \
      } \
    if( outputImageSpacingArg.isSet() ) \
      { \
      outputImageSpacingTemp = outputImageSpacingArg.getValue(); \
      } \
    if( outputImageSizeArg.isSet() ) \
      { \
      outputImageSizeTemp = outputImageSizeArg.getValue(); \
      } \
    if( outputImageOriginArg.isSet() ) \
      { \
      outputImageOriginTemp = outputImageOriginArg.getValue(); \
      } \
    if( directionMatrixArg.isSet() ) \
      { \
      directionMatrixTemp = directionMatrixArg.getValue(); \
      } \
    if( numberOfThreadArg.isSet() ) \
      { \
      numberOfThread = numberOfThreadArg.getValue(); \
      } \
    if( defaultPixelValueArg.isSet() ) \
      { \
      defaultPixelValue = defaultPixelValueArg.getValue(); \
      } \
    if( windowFunctionArg.isSet() ) \
      { \
      windowFunction = windowFunctionArg.getValue(); \
      } \
    if( splineOrderArg.isSet() ) \
      { \
      splineOrder = splineOrderArg.getValue(); \
      } \
    if( transformMatrixArg.isSet() ) \
      { \
      transformMatrixTemp = transformMatrixArg.getValue(); \
      } \
    if( transformTypeArg.isSet() ) \
      { \
      transformType = transformTypeArg.getValue(); \
      } \
    if( echoSwitchArg.isSet() ) \
      { \
      echoSwitch = echoSwitchArg.getValue(); \
      } \
    if( xmlSwitchArg.isSet() ) \
      { \
      xmlSwitch = xmlSwitchArg.getValue(); \
      } \
    if( processInformationAddressStringArg.isSet() ) \
      { \
      processInformationAddressString = processInformationAddressStringArg.getValue(); \
      } \
    if( returnParameterFileArg.isSet() ) \
      { \
      returnParameterFile = returnParameterFileArg.getValue(); \
      } \
    if( rotationPointArg.isSet() ) \
      { /* Assignment for rotationPoint */ \
      rotationPoint.clear(); \
      std::vector<std::string> words; \
      std::string sep(","); \
      splitString(rotationPointTemp, sep, words); \
      for (unsigned int _j = 0; _j < words.size(); _j++) \
        { \
        rotationPoint.push_back(atof(words[_j].c_str())); \
        } \
      } \
    if( outputImageSpacingArg.isSet() ) \
      { /* Assignment for outputImageSpacing */ \
      outputImageSpacing.clear(); \
      std::vector<std::string> words; \
      std::string sep(","); \
      splitString(outputImageSpacingTemp, sep, words); \
      for (unsigned int _j = 0; _j < words.size(); _j++) \
        { \
        outputImageSpacing.push_back(atof(words[_j].c_str())); \
        } \
      } \
    if( outputImageSizeArg.isSet() ) \
      { /* Assignment for outputImageSize */ \
      outputImageSize.clear(); \
      std::vector<std::string> words; \
      std::string sep(","); \
      splitString(outputImageSizeTemp, sep, words); \
      for (unsigned int _j = 0; _j < words.size(); _j++) \
        { \
        outputImageSize.push_back(atof(words[_j].c_str())); \
        } \
      } \
    if( outputImageOriginArg.isSet() ) \
      { /* Assignment for outputImageOrigin */ \
      outputImageOrigin.clear(); \
      std::vector<std::string> words; \
      std::string sep(","); \
      splitString(outputImageOriginTemp, sep, words); \
      for (unsigned int _j = 0; _j < words.size(); _j++) \
        { \
        outputImageOrigin.push_back(atof(words[_j].c_str())); \
        } \
      } \
    if( directionMatrixArg.isSet() ) \
      { /* Assignment for directionMatrix */ \
      directionMatrix.clear(); \
      std::vector<std::string> words; \
      std::string sep(","); \
      splitString(directionMatrixTemp, sep, words); \
      for (unsigned int _j = 0; _j < words.size(); _j++) \
        { \
        directionMatrix.push_back(atof(words[_j].c_str())); \
        } \
      } \
    if( transformMatrixArg.isSet() ) \
      { /* Assignment for transformMatrix */ \
      transformMatrix.clear(); \
      std::vector<std::string> words; \
      std::string sep(","); \
      splitString(transformMatrixTemp, sep, words); \
      for (unsigned int _j = 0; _j < words.size(); _j++) \
        { \
        transformMatrix.push_back(atof(words[_j].c_str())); \
        } \
      } \

#define GENERATE_ECHOARGS \
if (echoSwitch) \
{ \
std::cout << "Command Line Arguments" << std::endl; \
std::cout << "    inputVolume: " << inputVolume << std::endl; \
std::cout << "    outputVolume: " << outputVolume << std::endl; \
std::cout << "    referenceVolume: " << referenceVolume << std::endl; \
std::cout << "    transformationFile: " << transformationFile << std::endl; \
std::cout << "    deffield: " << deffield << std::endl; \
std::cout << "    typeOfField: " << typeOfField << std::endl; \
std::cout << "    interpolationType: " << interpolationType << std::endl; \
std::cout << "    noMeasurementFrame: " << noMeasurementFrame << std::endl; \
std::cout << "    correction: " << correction << std::endl; \
std::cout << "    ppd: " << ppd << std::endl; \
std::cout << "    transformsOrder: " << transformsOrder << std::endl; \
std::cout << "    notbulk: " << notbulk << std::endl; \
std::cout << "    space: " << space << std::endl; \
std::cout << "    rotationPoint: "; \
for (unsigned int _i =0; _i < rotationPoint.size(); _i++) \
{ \
std::cout << rotationPoint[_i] << ", "; \
} \
std::cout <<std::endl; \
std::cout << "    centeredTransform: " << centeredTransform << std::endl; \
std::cout << "    imageCenter: " << imageCenter << std::endl; \
std::cout << "    inverseITKTransformation: " << inverseITKTransformation << std::endl; \
std::cout << "    outputImageSpacing: "; \
for (unsigned int _i =0; _i < outputImageSpacing.size(); _i++) \
{ \
std::cout << outputImageSpacing[_i] << ", "; \
} \
std::cout <<std::endl; \
std::cout << "    outputImageSize: "; \
for (unsigned int _i =0; _i < outputImageSize.size(); _i++) \
{ \
std::cout << outputImageSize[_i] << ", "; \
} \
std::cout <<std::endl; \
std::cout << "    outputImageOrigin: "; \
for (unsigned int _i =0; _i < outputImageOrigin.size(); _i++) \
{ \
std::cout << outputImageOrigin[_i] << ", "; \
} \
std::cout <<std::endl; \
std::cout << "    directionMatrix: "; \
for (unsigned int _i =0; _i < directionMatrix.size(); _i++) \
{ \
std::cout << directionMatrix[_i] << ", "; \
} \
std::cout <<std::endl; \
std::cout << "    numberOfThread: " << numberOfThread << std::endl; \
std::cout << "    defaultPixelValue: " << defaultPixelValue << std::endl; \
std::cout << "    windowFunction: " << windowFunction << std::endl; \
std::cout << "    splineOrder: " << splineOrder << std::endl; \
std::cout << "    transformMatrix: "; \
for (unsigned int _i =0; _i < transformMatrix.size(); _i++) \
{ \
std::cout << transformMatrix[_i] << ", "; \
} \
std::cout <<std::endl; \
std::cout << "    transformType: " << transformType << std::endl; \
std::cout << "    echoSwitch: " << echoSwitch << std::endl; \
std::cout << "    xmlSwitch: " << xmlSwitch << std::endl; \
std::cout << "    processInformationAddressString: " << processInformationAddressString << std::endl; \
std::cout << "    returnParameterFile: " << returnParameterFile << std::endl; \
}
#define GENERATE_ProcessInformationAddressDecoding \
ModuleProcessInformation *CLPProcessInformation = 0; \
if (processInformationAddressString != "") \
{ \
sscanf(processInformationAddressString.c_str(), "%p", &CLPProcessInformation); \
}
#define PARSE_ARGS GENERATE_LOGO;GENERATE_XML;GENERATE_DECLARE;GENERATE_TCLAP;GENERATE_ECHOARGS;GENERATE_ProcessInformationAddressDecoding;
